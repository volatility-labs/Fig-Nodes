<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fig-Nodes PixiJS Proof-of-Concept - 120 FPS</title>
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.0/dist/pixi.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { 
    background: linear-gradient(135deg, #0a0a0f 0%, #16161f 50%, #1a1a2e 100%);
    overflow: hidden; 
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    color: #fff;
  }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0; height: 55px;
    background: rgba(10,10,15,0.98); backdrop-filter: blur(30px);
    border-bottom: 1px solid rgba(255,255,255,0.12); z-index: 1000;
    display: flex; align-items: center; padding: 0 24px; gap: 12px;
    box-shadow: 0 4px 24px rgba(0,0,0,0.5);
  }
  #toolbar button {
    background: linear-gradient(135deg, #2a2a3e, #1a1a2e);
    color: #fff; border: 1px solid rgba(255,255,255,0.12);
    border-radius: 10px; padding: 10px 18px; cursor: pointer;
    font-size: 13px; font-weight: 600; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
  #toolbar button:hover {
    background: linear-gradient(135deg, #3a3a4e, #2a2a3e);
    border-color: rgba(100,150,255,0.5);
    box-shadow: 0 4px 16px rgba(100,150,255,0.3);
    transform: translateY(-2px);
  }
  #toolbar button.run {
    background: linear-gradient(135deg, #4ade80, #22c55e);
    border-color: rgba(74,222,128,0.3);
  }
  #toolbar button.run:hover {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    box-shadow: 0 4px 16px rgba(74,222,128,0.4);
  }
  #fps-counter {
    margin-left: auto;
    font-size: 12px;
    font-family: 'Consolas', monospace;
    color: #4ade80;
    padding: 6px 12px;
    background: rgba(74,222,128,0.1);
    border-radius: 6px;
    border: 1px solid rgba(74,222,128,0.2);
  }
  #info {
    position: fixed; bottom: 24px; right: 24px;
    background: rgba(20,20,30,0.95); backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.15); border-radius: 12px;
    padding: 16px 20px; max-width: 280px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  }
  #info h3 {
    font-size: 14px; margin-bottom: 12px;
    color: #6496ff; font-weight: 600;
  }
  #info p {
    font-size: 12px; line-height: 1.6; color: #aaa; margin: 6px 0;
  }
  .status-good { color: #4ade80; }
  .status-warn { color: #facc15; }
</style>
</head>
<body>

<div id="toolbar">
  <button id="btn-polygon">+ Polygon Universe</button>
  <button id="btn-orb">+ ORB Filter</button>
  <button id="btn-vbp">+ VBP Filter</button>
  <button id="btn-chart">+ OHLCV Chart</button>
  <button id="btn-clear">Clear All</button>
  <button id="btn-run" class="run">▶ Run Graph</button>
  <span id="fps-counter">FPS: 0</span>
</div>

<!-- NEW: Canvas mount point for PixiJS -->
<div id="app"></div>

<div id="info">
  <h3>⚡ PixiJS Proof-of-Concept</h3>
  <p class="status-good">✓ GPU-accelerated WebGL</p>
  <p class="status-good">✓ 120 FPS rendering</p>
  <p class="status-good">✓ Smooth drag & drop</p>
  <p class="status-good">✓ Glassmorphism effects</p>
  <p class="status-good">✓ Glowing connections</p>
  <p style="margin-top: 12px; color: #6496ff;">
    <strong>Try it:</strong> Drag nodes, scroll to zoom, watch FPS counter!
  </p>
  <p style="margin-top: 8px; font-size: 11px; color: #777;">
    This demo uses your MacBook's GPU - no special hardware needed.
  </p>
</div>

<script>
// Wait for DOM to be ready
document.addEventListener('DOMContentLoaded', () => {

// ============================================================
// PixiJS Application Setup
// ============================================================
const app = new PIXI.Application({
  width: window.innerWidth,
  height: window.innerHeight - 55,
  backgroundColor: 0x0f0f1a,
  antialias: true,
  resolution: window.devicePixelRatio || 1,
  autoDensity: true
});
document.getElementById('app').appendChild(app.view);
app.view.style.display = 'block';

// FPS Counter
let lastTime = performance.now();
let frameCount = 0;
app.ticker.add(() => {
  frameCount++;
  const now = performance.now();
  if (now - lastTime >= 500) {
    const fps = Math.round((frameCount * 1000) / (now - lastTime));
    document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
    document.getElementById('fps-counter').style.color = fps >= 100 ? '#4ade80' : fps >= 60 ? '#facc15' : '#ef4444';
    frameCount = 0;
    lastTime = now;
  }
});

// ============================================================
// Node Container (with zoom/pan support)
// ============================================================
const viewport = new PIXI.Container();
app.stage.addChild(viewport);

let isDraggingCanvas = false;
let canvasStart = { x: 0, y: 0 };

app.view.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.95 : 1.05;
  const newScale = Math.max(0.3, Math.min(2.5, viewport.scale.x * delta));
  viewport.scale.set(newScale);
  redrawAllConnections();
});

app.view.addEventListener('mousedown', (e) => {
  if (e.shiftKey || e.button === 1) {
    isDraggingCanvas = true;
    canvasStart = { x: e.clientX - viewport.x, y: e.clientY - viewport.y };
  }
});

app.view.addEventListener('mousemove', (e) => {
  if (isDraggingCanvas) {
    viewport.x = e.clientX - canvasStart.x;
    viewport.y = e.clientY - canvasStart.y;
    redrawAllConnections();
  }
});

app.view.addEventListener('mouseup', () => {
  isDraggingCanvas = false;
});

// ============================================================
// Glassmorphism Node Class
// ============================================================
class PixiNode {
  constructor(title, x, y, category = 'Custom', inputs = [], outputs = []) {
    this.title = title;
    this.category = category;
    this.inputs = inputs;
    this.outputs = outputs;
    this.connections = [];
    
    this.container = new PIXI.Container();
    this.container.x = x;
    this.container.y = y;
    this.container.eventMode = 'static';
    this.container.cursor = 'move';
    
    const portCount = Math.max(inputs.length, outputs.length);
    this.width = 260;
    this.height = 80 + portCount * 28;
    
    this.render();
    this.makeInteractive();
    viewport.addChild(this.container);
  }
  
  render() {
    // Clear previous graphics
    this.container.removeChildren();
    
    // Main node background with glassmorphism
    const bg = new PIXI.Graphics();
    bg.beginFill(0x1e1e2d, 0.95);
    bg.lineStyle(1.5, 0xffffff, 0.15);
    bg.drawRoundedRect(0, 0, this.width, this.height, 14);
    bg.endFill();
    
    // Inner glow
    bg.lineStyle(1, 0x6496ff, 0.3);
    bg.drawRoundedRect(2, 2, this.width - 4, this.height - 4, 12);
    this.container.addChild(bg);
    
    // Title bar
    const titleBg = new PIXI.Graphics();
    titleBg.beginFill(0x323246, 0.9);
    titleBg.drawRoundedRect(0, 0, this.width, 40, 14);
    titleBg.endFill();
    this.container.addChild(titleBg);
    
    // Category tag
    const categoryTag = new PIXI.Text(this.category.toUpperCase(), {
      fill: 0x6496ff, fontSize: 9, fontWeight: '600',
      letterSpacing: 0.5
    });
    categoryTag.x = 14;
    categoryTag.y = 10;
    this.container.addChild(categoryTag);
    
    // Title
    const titleText = new PIXI.Text(this.title, {
      fill: 0xffffff, fontSize: 14, fontWeight: '600',
      dropShadow: true, dropShadowColor: 0x000000,
      dropShadowBlur: 4, dropShadowDistance: 2
    });
    titleText.x = 14;
    titleText.y = 24;
    this.container.addChild(titleText);
    
    // Render ports
    this.portGraphics = [];
    this.renderPorts();
  }
  
  renderPorts() {
    const maxPorts = Math.max(this.inputs.length, this.outputs.length);
    
    // Input ports (left side)
    this.inputs.forEach((portName, i) => {
      const y = 60 + i * 28;
      
      // Port circle
      const port = new PIXI.Graphics();
      port.beginFill(0xff6b6b, 0.25);
      port.lineStyle(2.5, 0xff6b6b, 1);
      port.drawCircle(0, 0, 8);
      port.endFill();
      port.x = 0;
      port.y = y;
      port.eventMode = 'static';
      port.cursor = 'pointer';
      
      // Glow on hover
      port.on('pointerover', () => {
        port.clear();
        port.beginFill(0xff6b6b, 0.5);
        port.lineStyle(3, 0xff6b6b, 1);
        port.drawCircle(0, 0, 10);
        port.endFill();
      });
      port.on('pointerout', () => {
        port.clear();
        port.beginFill(0xff6b6b, 0.25);
        port.lineStyle(2.5, 0xff6b6b, 1);
        port.drawCircle(0, 0, 8);
        port.endFill();
      });
      
      this.container.addChild(port);
      
      // Port label
      const label = new PIXI.Text(portName, {
        fill: 0xbbbbbb, fontSize: 11, fontWeight: '500'
      });
      label.x = 18;
      label.y = y - 8;
      this.container.addChild(label);
      
      this.portGraphics.push({ graphics: port, name: portName, type: 'input', index: i });
    });
    
    // Output ports (right side)
    this.outputs.forEach((portName, i) => {
      const y = 60 + i * 28;
      
      // Port circle
      const port = new PIXI.Graphics();
      port.beginFill(0x4ecdc4, 0.25);
      port.lineStyle(2.5, 0x4ecdc4, 1);
      port.drawCircle(0, 0, 8);
      port.endFill();
      port.x = this.width;
      port.y = y;
      port.eventMode = 'static';
      port.cursor = 'pointer';
      
      // Glow on hover
      port.on('pointerover', () => {
        port.clear();
        port.beginFill(0x4ecdc4, 0.5);
        port.lineStyle(3, 0x4ecdc4, 1);
        port.drawCircle(0, 0, 10);
        port.endFill();
      });
      port.on('pointerout', () => {
        port.clear();
        port.beginFill(0x4ecdc4, 0.25);
        port.lineStyle(2.5, 0x4ecdc4, 1);
        port.drawCircle(0, 0, 8);
        port.endFill();
      });
      
      this.container.addChild(port);
      
      // Port label
      const label = new PIXI.Text(portName, {
        fill: 0xbbbbbb, fontSize: 11, fontWeight: '500'
      });
      label.anchor.set(1, 0);
      label.x = this.width - 18;
      label.y = y - 8;
      this.container.addChild(label);
      
      this.portGraphics.push({ graphics: port, name: portName, type: 'output', index: i });
    });
  }
  
  makeInteractive() {
    let dragging = false;
    let startPos = { x: 0, y: 0 };
    let originalAlpha = 1;
    
    this.container.on('pointerdown', (e) => {
      // Only drag if clicking on the node body, not ports
      if (e.target === this.container || e.target.parent === this.container) {
        dragging = true;
        const pos = e.data.getLocalPosition(viewport);
        startPos = {
          x: pos.x - this.container.x,
          y: pos.y - this.container.y
        };
        this.container.alpha = 0.85;
        this.container.zIndex = 1000;
        e.stopPropagation();
      }
    });
    
    this.container.on('pointermove', (e) => {
      if (dragging) {
        const pos = e.data.getLocalPosition(viewport);
        this.container.x = pos.x - startPos.x;
        this.container.y = pos.y - startPos.y;
        redrawAllConnections();
      }
    });
    
    this.container.on('pointerup', () => {
      if (dragging) {
        dragging = false;
        this.container.alpha = 1;
        this.container.zIndex = 0;
      }
    });
    
    this.container.on('pointerupoutside', () => {
      if (dragging) {
        dragging = false;
        this.container.alpha = 1;
        this.container.zIndex = 0;
      }
    });
  }
  
  getPortPosition(portName, isInput) {
    const port = this.portGraphics.find(p => p.name === portName && p.type === (isInput ? 'input' : 'output'));
    if (!port) return null;
    
    return {
      x: this.container.x + port.graphics.x,
      y: this.container.y + port.graphics.y
    };
  }
}

// ============================================================
// Connection Rendering
// ============================================================
const connectionsLayer = new PIXI.Graphics();
viewport.addChild(connectionsLayer);

const connections = [];

function addConnection(fromNode, fromPort, toNode, toPort) {
  connections.push({ fromNode, fromPort, toNode, toPort });
  redrawAllConnections();
}

function redrawAllConnections() {
  connectionsLayer.clear();
  
  connections.forEach(conn => {
    const from = conn.fromNode.getPortPosition(conn.fromPort, false);
    const to = conn.toNode.getPortPosition(conn.toPort, true);
    
    if (!from || !to) return;
    
    const midX = (from.x + to.x) / 2;
    
    // Glowing connection line
    connectionsLayer.lineStyle(2.5, 0x6496ff, 0.8);
    connectionsLayer.moveTo(from.x, from.y);
    connectionsLayer.bezierCurveTo(
      midX, from.y,
      midX, to.y,
      to.x, to.y
    );
    
    // Animated flow dot
    const t = (Date.now() % 2000) / 2000;
    const dotX = from.x + (to.x - from.x) * t;
    const dotY = from.y + (to.y - from.y) * t; // Simplified; real bezier would be better
    
    connectionsLayer.beginFill(0x6496ff, 0.9);
    connectionsLayer.drawCircle(dotX, dotY, 4);
    connectionsLayer.endFill();
  });
}

// Animate connections
app.ticker.add(() => {
  if (connections.length > 0) {
    redrawAllConnections();
  }
});

// ============================================================
// Node Instances
// ============================================================
const nodes = [];

function addPolygonNode() {
  const node = new PixiNode(
    'Polygon Universe',
    150 + nodes.length * 80,
    150,
    'Data Source',
    [],
    ['ohlcv_bundle']
  );
  nodes.push(node);
}

function addOrbFilter() {
  const node = new PixiNode(
    'ORB Filter',
    150 + nodes.length * 80,
    150,
    'Market Filter',
    ['ohlcv_bundle'],
    ['filtered_bundle']
  );
  nodes.push(node);
}

function addVbpFilter() {
  const node = new PixiNode(
    'VBP Filter',
    150 + nodes.length * 80,
    150,
    'Market Filter',
    ['ohlcv_bundle'],
    ['filtered_bundle', 'vbp_levels']
  );
  nodes.push(node);
}

function addChartNode() {
  const node = new PixiNode(
    'OHLCV Plot',
    150 + nodes.length * 80,
    150,
    'Visualization',
    ['ohlcv_bundle', 'vbp_levels'],
    ['images']
  );
  nodes.push(node);
}

function clearAll() {
  nodes.forEach(n => viewport.removeChild(n.container));
  nodes.length = 0;
  connections.length = 0;
  redrawAllConnections();
}

// ============================================================
// Sample Workflow
// ============================================================
function createSampleWorkflow() {
  const polygon = new PixiNode('Polygon Universe', 100, 120, 'Data Source', [], ['ohlcv_bundle']);
  const orb = new PixiNode('ORB Filter', 450, 100, 'Market Filter', ['ohlcv_bundle'], ['filtered_bundle']);
  const vbp = new PixiNode('VBP Filter', 800, 100, 'Market Filter', ['ohlcv_bundle'], ['filtered_bundle', 'vbp_levels']);
  const chart = new PixiNode('OHLCV Plot', 1150, 80, 'Visualization', ['ohlcv_bundle', 'vbp_levels'], ['images']);
  
  nodes.push(polygon, orb, vbp, chart);
  
  // Connect them
  setTimeout(() => {
    addConnection(polygon, 'ohlcv_bundle', orb, 'ohlcv_bundle');
    addConnection(orb, 'filtered_bundle', vbp, 'ohlcv_bundle');
    addConnection(vbp, 'filtered_bundle', chart, 'ohlcv_bundle');
    addConnection(vbp, 'vbp_levels', chart, 'vbp_levels');
  }, 100);
}

// Run Graph (would call FastAPI backend)
async function runGraph() {
  console.log('Running graph with', nodes.length, 'nodes');
  document.getElementById('fps-counter').textContent = 'RUNNING...';
  document.getElementById('fps-counter').style.color = '#facc15';
  
  // Simulate backend call
  await new Promise(r => setTimeout(r, 500));
  
  document.getElementById('fps-counter').textContent = 'COMPLETE!';
  document.getElementById('fps-counter').style.color = '#4ade80';
  
  setTimeout(() => {
    frameCount = 0;
    lastTime = performance.now();
  }, 1000);
}

// ============================================================
// Initialize with sample workflow
// ============================================================
createSampleWorkflow();

// Resize handler
window.addEventListener('resize', () => {
  app.renderer.resize(window.innerWidth, window.innerHeight - 55);
});

// ============================================================
// Keyboard Shortcuts
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') clearAll();
  if (e.key === 'r' || e.key === 'R') runGraph();
  if (e.key === '+' || e.key === '=') {
    viewport.scale.set(Math.min(2.5, viewport.scale.x * 1.2));
    redrawAllConnections();
  }
  if (e.key === '-' || e.key === '_') {
    viewport.scale.set(Math.max(0.3, viewport.scale.x * 0.8));
    redrawAllConnections();
  }
  if (e.key === '0') {
    viewport.scale.set(1);
    viewport.x = 0;
    viewport.y = 0;
    redrawAllConnections();
  }
});

console.log('%c⚡ PixiJS Proof-of-Concept Loaded!', 'color: #4ade80; font-size: 16px; font-weight: bold;');
console.log('%cDrag nodes, scroll to zoom, shift+drag to pan canvas', 'color: #6496ff; font-size: 12px;');
console.log('%cKeyboard: R = run, Esc = clear, +/- = zoom, 0 = reset', 'color: #aaa; font-size: 11px;');

// Initialize the sample workflow on page load
createSampleWorkflow();
console.log('%c✓ Sample workflow created with 4 nodes', 'color: #4ade80; font-size: 12px;');

// Setup button event listeners
document.getElementById('btn-polygon').addEventListener('click', addPolygonNode);
document.getElementById('btn-orb').addEventListener('click', addOrbFilter);
document.getElementById('btn-vbp').addEventListener('click', addVbpFilter);
document.getElementById('btn-chart').addEventListener('click', addChartNode);
document.getElementById('btn-clear').addEventListener('click', clearAll);
document.getElementById('btn-run').addEventListener('click', runGraph);

}); // End DOMContentLoaded
</script>

</body>
</html>

