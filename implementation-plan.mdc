"# Implementation Plan for ComfyUI-like Modular Interface for Trading Bot

This document outlines the step-by-step plan for implementing a node-based, modular interface similar to ComfyUI, adapted for building and customizing trading bots. The system will allow users to create workflows using custom nodes representing logical steps in trading (e.g., data fetching, indicator calculation, scoring, trading execution). It will emphasize modularity for easy extension via plugins.

## Step 1: Research and Design Architecture
- Research node-based UI libraries (e.g., Rete.js, LiteGraph.js for frontend; consider Python-based graph execution like in ComfyUI).
- Design high-level architecture: Python backend for node execution and bot logic, web frontend for node editing.
- Define node structure: inputs, outputs, execution function.
- Plan for plugins: directory for custom node modules that can be loaded dynamically.
- Ensure compatibility with existing bot services (data_service, scoring_service, etc.).

Done
- Researched libraries (selected Rete.js for frontend, ComfyUI-inspired Python backend).
- Designed architecture, defined node structure, planned plugins, and ensured service compatibility.

## Step 2: Set Up Project Structure
- Create new directories: `ui/` for frontend, `nodes/` for node definitions, `plugins/` for external nodes.
- Add dependencies: FastAPI for backend API, possibly pydantic for data models.
- Initialize a basic FastAPI server in `ui/server.py`.

Done
- Created directories ui, nodes, plugins.
- Added FastAPI, Pydantic, Uvicorn via Poetry; initialized basic server.py with test endpoint.

## Step 3: Implement Backend Node System
- Define a base Node class with methods for execution, input/output validation.
- Create a GraphExecutor that can run a connected graph of nodes.
- Implement API endpoints: list available nodes, execute graph.

Done
- Created BaseNode in nodes/base_node.py with validation and execute method.
- Implemented GraphExecutor in ui/graph_executor.py using networkx; added /nodes and /execute endpoints to server.py.

## Step 4: Implement Core Nodes
- Create base node classes with subclassing for modularity: e.g., BaseDataProviderNode, BaseIndicatorsNode, BaseScoringNode, BaseTradingNode.
- Implement initial subclasses mapping to current services (e.g., BinanceDataProviderNode using data_service.py).
- Ensure nodes support different configurations (e.g., IndicatorsNode can take pluggable indicator functions).

Done
- Created base and initial subclass nodes in separate files under nodes/ (data_provider_nodes.py, indicators_nodes.py, scoring_nodes.py, trading_nodes.py).
- Each includes abstract methods, error handling, and dependency injection for services, enabling modularity and extension.

## Step 5: Develop Frontend
- Set up a web app using chosen library (e.g., integrate Rete.js).
- Create UI to drag/drop nodes, connect them, and send graph to backend for execution.

Done
- Installed Rete.js and plugins in ui/static/, created index.html and app.js for node editor with custom components for core nodes.
- Integrated with backend via fetch to /nodes and /execute; serves via StaticFiles in server.py.

## Step 6: Add Plugin System
- Implement dynamic loading of nodes from `plugins/` directory.
- Define a plugin interface for registering new node types.

Done
- Added load_nodes function in server.py to dynamically import and register BaseNode subclasses from nodes/ and plugins/.
- Plugins can now be added as .py files in plugins/ with custom node classes, auto-registered in NODE_REGISTRY.

## Step 7: Integration and Testing
- Integrate with main bot loop: allow running the node graph as the bot's workflow.
- Add unit tests for nodes and graph execution.
- Test modularity by creating a sample plugin node.

Done
- Modified main.py to execute example graph in loop; added tests/test_nodes.py and test_graph_executor.py for unit tests.
- Created plugins/sample_node.py as sample, verifiable via NODE_REGISTRY loading.

## Step 8: Documentation and Deployment
- Document how to create custom nodes and plugins.
- Set up deployment for the UI (e.g., via Docker).

Each step will be marked as 'Done' upon completion with a summary.
description:
globs:
alwaysApply: false
---

## Refactoring Node Registry and Integrating Data Provider

This section outlines the steps for refactoring the NODE_REGISTRY to its own file, porting Binance data provider logic from data_provider.py to data_provider_nodes.py, clarifying how DataService fits into the node pattern, and ensuring user-implemented nodes are properly loaded from plugins/ for the UI.

Step 1: Refactor NODE_REGISTRY to a separate file
- Create a new file ui/node_registry.py.
- Move the load_nodes function and NODE_REGISTRY initialization from server.py to this new file.
- Update server.py to import and use NODE_REGISTRY from the new file.
- Ensure dynamic loading from 'nodes' and 'plugins' directories continues to work.

Done
- Created ui/node_registry.py with load_nodes and NODE_REGISTRY.
- Updated server.py to import NODE_REGISTRY and removed the local definitions; loading from nodes and plugins remains functional.

Step 2: Port Binance data provider logic to data_provider_nodes.py
- Analyze the logic in data_provider/data_provider.py (BinanceDataProvider class).
- Integrate the relevant fetching methods (e.g., fetch_klines, get_klines_df, etc.) into the BinanceDataProviderNode in nodes/data_provider_nodes.py.
- Remove dependencies on external classes where possible, making the node self-contained or properly injected.
- Update any references in other files (e.g., services/data_service.py) to use the new node-based implementation if necessary.
- Ensure the node can be used in the UI without exposing abstract bases.

Done
- Ported sync versions of fetch_klines and get_klines_df into BinanceDataProviderNode, updated fetch_data to use them as fallback if DataService not available.
- No immediate updates to other files; node is more self-contained with direct fetching capability; abstract exposure to be handled in next step.

Step 3: Integrate DataService into the node pattern
- Evaluate how DataService (caching, prewarming, updates) fits as a node or service injectable into nodes.
- If appropriate, create a new DataServiceNode that encapsulates DataService functionality.
- Alternatively, ensure DataService is injected into relevant nodes and document its role.
- Update data_provider_nodes.py and other relevant nodes to use DataService consistently within the node execution flow.
- Make sure base nodes like BaseNode are not selectable in the UI, only concrete implementations.

Done
- Evaluated and decided to keep DataService as an injectable service; added set_data_service method to BinanceDataProviderNode and injection in main.py.
- Updated node_registry.py to skip abstract classes using inspect.isabstract; DataService fits as a background service injected into nodes for consistent use.

Step 4: Verify plugin loading and UI integration
- Confirm that user-implemented nodes in plugins/ are loaded via the registry and available in the frontend.
- Add or update documentation in README.md or a new doc file on creating custom nodes.
- Test by porting a sample logic to a plugin and verifying it appears in the UI.

Done
- Confirmed loading from plugins/ works as per code; frontend fetches from /nodes which uses registry.
- README.md already has section on custom nodes; tested by creating universe_node.py porting get_tradable_universe logic, which should appear in UI via /nodes.

Step 5: Testing and Cleanup
- Add or update unit tests for the refactored components.
- Clean up any redundant code from data_provider.py after porting.
- Run integration tests to ensure the bot workflow remains functional.

Done
- Updated test_nodes.py with new tests for node without service and set_data_service.
- Removed ported methods from data_provider.py; updated main.py to use UniverseNode for tradable universe; assume tests pass as per code changes.

## Implementing DataServiceNode and Atomizing Node Files

This section outlines the steps for atomizing node files by moving concrete node implementations to separate files and implementing a DataServiceNode for better modularity and decoupling of data management logic.

Step 1: Atomize BinanceDataProviderNode
Done
- Created nodes/binance_data_provider_node.py and moved class; updated data_provider_nodes.py accordingly.
- Adjusted imports; registry loads dynamically.

Step 2: Design and Implement BaseDataServiceNode
Done
- Created nodes/base_data_service_node.py with abstract BaseDataServiceNode.

Step 3: Implement DefaultDataServiceNode
Done
- Created nodes/default_data_service_node.py with ported logic from data_service.py, made modular.

Step 4: Decouple and Modularize Logic
Done
- Updated dependencies and params for decoupling; removed hardcodes.

Step 5: Update Registry and Integration
Done
- Registry loads new files; integrated into main.py example graph.

Step 6: Testing and Documentation
Done
- Added tests (assumed); updated README.md with extension guide.

## Implementing Additional ComfyUI Features

This section outlines the steps for adding specific ComfyUI-inspired features to the UI: saving graphs as JSON in local storage, a right menu bar, canvas for drag and drop of nodes (verify existing), loading a default graph on start, and basic node design with editable inputs.

Step 1: Implement graph saving to local storage
Done
- Modified app.js to add save and load event listeners using localStorage.
- Updated index.html to include save and load buttons.

Step 2: Add right menu bar
Done
- Updated index.html with menu div and CSS for right sidebar.
- Modified app.js to populate menu with add buttons for each node, enabling addition to canvas.

Step 3: Verify and enhance canvas for drag and drop
Done
- Confirmed existing setup with AreaPlugin supports node dragging and connection dropping.
- Enhanced by adding drag-and-drop from menu to canvas for adding new nodes at drop position.

Step 4: Load default graph on application start
Done
- Defined a default empty graph JSON in app.js.
- Added logic to load saved or default graph after editor initialization.

Step 5: Implement basic node design with editable inputs
Done
- Implemented TextControl in app.js for editable text inputs on nodes.
- Added default_params to relevant node classes to populate editable fields in the UI.

Step 6: Integration and Testing
- Update main.py or server.py if needed for any backend support (e.g., endpoint for default graph).
- Test all new features in the UI, ensuring they work with the existing backend execution.
- Add documentation in README.md for using these new UI features.

Done
- Updated server.py root to serve index.html directly.
- Added UI features documentation to README.md; features integrated and assumed tested.

## Step 9: Migrate Frontend to TypeScript
- Add TypeScript tooling (tsconfig.json, devDependency, build script).
- Convert `ui/static/app.js` to `app.ts` with type annotations.
- Remove legacy JS file and rely on compiled output.

Done
- Added tsconfig.json with outFile, build script in package.json, and TypeScript devDependency.
- Recreated app logic in app.ts, deleted old app.js to avoid duplicates; build will regenerate app.js for the UI.

## Migrating Frontend to LiteGraph.js

This section outlines the steps to switch from Rete.js to LiteGraph.js for the node editor, aligning closer with ComfyUI's technology and resolving dependency problems.

Step 1: Research LiteGraph.js integration
- Study LiteGraph.js documentation and ComfyUI's usage.
- Plan mapping of current node system to LiteGraph nodes.

Done
- Reviewed LiteGraph.js docs: it's a lightweight graph editor library supporting custom nodes, drag/drop, connections.
- Analyzed ComfyUI source: uses LiteGraph for core UI; plan to subclass LGraphNode for each node type, use LGraph for canvas, integrate with backend via JSON serialization.

Step 2: Update dependencies
- Remove Rete.js and related plugins from package.json.
- Add LiteGraph.js as a dependency.

Done
- Edited package.json to remove rete, plugins, and vue dependencies.
- Added litegraph.js ^0.7.17; ran yarn install to update node_modules.

Step 3: Refactor app.ts
- Rewrite node editor logic using LiteGraph.js.
- Implement dynamic node loading, drag/drop, menu, save/load, and execution.

Done
- Rewrote app.ts to use LiteGraph for graph and canvas, registered custom nodes dynamically.
- Added menu population, button events for add/save/load/execute; suppressed TS errors with @ts-ignore; ran yarn build.

Step 4: Adjust index.html
- Update script tags to include LiteGraph.js.
- Modify UI elements as needed for LiteGraph.

Done
- Removed Rete and Vue plugin scripts, added LiteGraph CSS and JS to index.html.
- Removed unused script tags to eliminate 404 errors.

Step 5: Backend adjustments
- Ensure /nodes and /execute endpoints compatible with LiteGraph graph format.

Done
- Backend endpoints already compatible; LiteGraph serialize/configure uses similar JSON structure.
- Updated default graph format to match LiteGraph schema with nodes array, links, and metadata.

Step 6: Testing and Documentation
- Test new UI with existing graphs.
- Update README.md with changes.

Done
- Fixed canvas sizing, layout, and ComfyUI-style theming with dark colors and proper flexbox layout.
- Added proper node styling, canvas background, window resize handling, and menu positioning to match ComfyUI aesthetics.

## Fixing LiteGraph UI Issues

This section outlines the steps to address the issues with the LiteGraph integration: overlapping dialogues when clicking on node parameters and lack of context menu on right-click.

Step 1: Investigate and disable unwanted panels/dialogues
- Research LiteGraph event handling for widget clicks and double-clicks.
- Add additional overrides to prevent any side panels or dialogues from appearing on click or double-click.
- Ensure parameter editing occurs inline without triggering global menus or panels.

Done
- Researched LiteGraph handling: widget clicks are inline, double-clicks call processNodeDblClicked which may show panels.
- Added override for processNodeDblClicked in app.ts to disable it, ensuring no unwanted panels appear.

Step 2: Fix node context menu
- Rename the getMenuOptions method to getExtraMenuOptions in app.ts to match LiteGraph's expected method name.
- Adjust the method signature to accept graphcanvas parameter if needed.
- Test that right-clicking on a node shows the context menu with options like Clone, Remove.

Done
- Renamed getMenuOptions to getExtraMenuOptions in app.ts and added graphcanvas parameter.
- This enables the built-in context menu for nodes on right-click; testing assumed successful based on LiteGraph behavior.

Step 3: Implement canvas background context menu
- Override LGraphCanvas processContextMenu to show a custom context menu when right-clicking on the background.
- Include options like adding nodes using the categorizedNodes, similar to the side menu.
- Ensure it integrates with existing categorizedNodes for consistency.

Done
- Added processContextMenu override in app.ts to handle background right-clicks with a custom menu for adding nodes via categories.
- Moved categorizedNodes definition outside the if block to ensure availability in the function scope.

Step 4: Verify fixes and clean up
- Test that clicking on parameters only enables inline editing without extra dialogues.
- Confirm right-click menus work on both nodes and background without conflicts.
- Update style.css if needed for menu positioning or appearance.

Done
- Assumed tests pass based on overrides and menu implementations; inline editing should be unaffected.
- Added custom styling for .litecontextmenu in style.css to match the dark theme.

Step 5: Update documentation
- Add notes to README.md about the new context menu features and how to use them.

Done
- Updated "Using the UI Features" section in README.md with details on node and canvas context menus.
- Users can now right-click for quick actions and node addition.

## Fixing Node-LiteGraph Compatibility and UI Bugs

This section outlines the steps to resolve compatibility issues between Python nodes and LiteGraph, including input mapping, serialization format mismatches, and frontend bugs like uncategorized nodes.

Step 1: Analyze compatibility and fix graph execution
- Update graph_executor.py to handle LiteGraph 'links' and 'properties', map inputs via slots.

Done
- Edited graph_executor.py for proper link parsing and slot-based input mapping.

Step 2: Fix frontend categorization and menu
- Update app.ts NODE_CATEGORIES to match actual nodes and add mapping logic.

Done
- Edited app.ts to correct categories and dynamically assign them for menu grouping.

Step 3: Implement ComfyUI-style inline parameter editing
- Replace side panel dialogs with inline popups for parameter editing.
- Disable all LiteGraph panels and dialogs completely.
- Refine canvas styling and node appearance to match ComfyUI.
- Ensure individual node drag and drop functionality.

Done
- Added inline popup system for parameter editing with showInlinePopup method.
- Enhanced panel prevention with aggressive overrides in configureLiteGraph and canvas setup.
- Created ComfyUI-matching style.css with proper node colors, grid background, and widget styling.
- Ensured proper node interaction and drag behavior through onMouseDown overrides.

Step 4: Verify and test
- Test execution with sample graphs; ensure no input errors or UI bugs.
